# -*- coding: utf-8 -*-
"""
Script da aula de Introdução à biblioteca NumPy.

Data: 08/09/2025
Professor: Pinho

Resumo dos tópicos a serem estudados para a prova, conforme anotações:
- Biblioteca NumPy
- doctest, documentação, comentários
- Modulurização e testes unitários
- Closure e decoradores
"""

import numpy as np

# ==============================================================================
# 1. INTRODUÇÃO: O QUE É UM NDARRAY?
# ==============================================================================
print("--- 1. Introdução: O que é um NDArray? ---")

print("Versão do NumPy:", np.__version__)

# A intenção do professor é que comecemos a usar ndarrays (N-dimensional arrays)
# em vez de listas, principalmente para computação numérica e científica.
# NDArrays são mais rápidos e consomem menos memória.

# Array de 1 dimensão (vetor)
array_1d = np.array([1, 2, 3])

# Array de 2 dimensões (matriz)
array_2d = np.array([[1, 2, 3], [4, 5, 6]])

print("\nArray 1D (vetor):\n", array_1d)
print("\nArray 2D (matriz):\n", array_2d)


# ==============================================================================
# 2. PROPRIEDADES DOS NDARRAYS
# ==============================================================================
print("\n" + "#"*50)
print("--- 2. Propriedades dos NDArrays ---")

# Formato (shape): uma tupla que indica o tamanho de cada dimensão.
print("\nFormato (shape):")
print("  - 1D:", array_1d.shape)  # Saída: (3,) -> 3 elementos na primeira dimensão
print("  - 2D:", array_2d.shape)  # Saída: (2, 3) -> 2 linhas e 3 colunas

# Tamanho (size): o número total de elementos no array.
print("\nTamanho (size):")
print("  - 1D:", array_1d.size)   # Saída: 3
print("  - 2D:", array_2d.size)   # Saída: 6

# Tipo dos Dados (dtype): o tipo de dado dos elementos do array.
print("\nTipo dos Dados (dtype):")
print("  - 1D:", array_1d.dtype)  # Saída: int64 (ou int32 dependendo do sistema)
print("  - 2D:", array_2d.dtype)
# Nota do professor: NumPy usa tipos de dados fixos no estilo da linguagem C
# (int32, int64, float64) para otimizar o uso de memória e a velocidade,
# removendo as "firulas" (overhead) que os objetos Python padrão possuem.

# Número de Dimensões (ndim):
print("\nNúmero de Dimensões (ndim):")
print("  - 1D:", array_1d.ndim)   # Saída: 1
print("  - 2D:", array_2d.ndim)   # Saída: 2


# ==============================================================================
# 3. OUTRAS FORMAS DE CRIAÇÃO DE ARRAYS
# ==============================================================================
print("\n" + "#"*50)
print("--- 3. Outras Formas de Criação de Arrays ---")

# Shape é uma tupla que define o formato do array a ser criado.
print("\nArray de Zeros (2 linhas, 3 colunas):\n", np.zeros((2, 3)))
print("\nArray de Uns (2 linhas, 3 colunas):\n", np.ones((2, 3)))
print("\nArray Preenchido com um valor (matriz 5x5 com o valor 42):\n", np.full((5, 5), 42))
print("\nArray com uma sequência (de 0 a 10, de 2 em 2):\n", np.arange(0, 10, 2))
print("\nArray com espaçamento linear (5 números entre 0 e 1):\n", np.linspace(0, 1, 5))
print("\nArray com valores aleatórios (2x2 entre 0 e 1):\n", np.random.rand(2, 2))


# ==============================================================================
# 4. INDEXAÇÃO E SLICING (O "CRUD" DOS ARRAYS)
# ==============================================================================
print("\n" + "#"*50)
print("--- 4. Indexação e Slicing (O 'CRUD' dos Arrays) ---")
matriz = np.array([[10, 20, 30], [40, 50, 60], [70, 80, 90]])
print("Matriz original:\n", matriz)

# Retrieve (Leitura)
print("\nElemento da linha 1, coluna 2 (valor 60):", matriz[1, 2])
print("\nPrimeira linha inteira:", matriz[0])
print("\nSegunda coluna inteira:\n", matriz[:, 1]) # O ':' significa "todas as linhas"
print("\nÚltima linha:", matriz[-1])
print("\nSubmatriz (linhas 0 a 1, colunas 1 a 2):\n", matriz[0:2, 1:3])

# Update (Atualização)
matriz[0, 0] = 11
print("\nMatriz com valor atualizado (posição [0,0]):\n", matriz)


# ==============================================================================
# 5. OPERAÇÕES ARITMÉTICAS E AGREGAÇÕES
# ==============================================================================
print("\n" + "#"*50)
print("--- 5. Operações Aritméticas e Agregações ---")
x = np.array([[1, 2], [3, 4]])
y = np.array([[5, 6], [7, 8]])
print("Matriz X:\n", x)
print("Matriz Y:\n", y)

# Operações elemento a elemento (diferente de listas, que concatenariam)
print("\nSoma (X + Y):\n", x + y)
print("\nMultiplicação (X * Y):\n", x * y)

# Operações matriciais
print("\nProduto Matricial (Dot Product) (X @ Y):\n", x @ y)
print("\nMatriz Transposta de X (X.T):\n", x.T)

# Agregações
print("\nSoma de todos os elementos de X:", np.sum(x))
print("\nSoma de X por colunas (axis=0):", np.sum(x, axis=0)) # Soma [1,3] e [2,4]
print("\nSoma de X por linhas (axis=1):", np.sum(x, axis=1))   # Soma [1,2] e [3,4]


# ==============================================================================
# 6. ESTATÍSTICA BÁSICA
# ==============================================================================
print("\n" + "#"*50)
print("--- 6. Estatística Básica ---")
# Cria um array de 10 elementos com inteiros aleatórios entre 1 e 99
data = np.random.randint(1, 100, size=10)
print("Array de dados aleatórios:", data)

# Nota do professor: Funções como np.mean() são funções do módulo, e não
# métodos do objeto (como data.mean()), para ganho de performance.
print("\nMédia:", np.mean(data))
print("Valor Máximo:", np.max(data))
print("Índice do Valor Máximo:", np.argmax(data))
print("Desvio Padrão:", np.std(data))


# ==============================================================================
# 7. INDEXAÇÃO BOOLEANA (FILTROS)
# ==============================================================================
print("\n" + "#"*50)
print("--- 7. Indexação Booleana (Filtros) ---")
# A dúvida final da aula: "como assim passar um array como índice?"
# A resposta é: podemos usar um array de booleanos (True/False) como um filtro.

array_ = np.array([10, 15, 20, 25, 30])
print("\nArray original:", array_)

# Passo 1: Criar a condição. A condição é aplicada a cada elemento,
# gerando um novo array de mesma dimensão, mas com valores True ou False.
condicao = array_ > 20
print("\nCondição (array_ > 20) resulta em um array booleano:", condicao)

# Passo 2: Usar o array booleano como um filtro (ou "máscara").
# O NumPy retorna apenas os elementos do array original onde a posição
# correspondente no filtro é `True`.
print("\nValores maiores que 20 (array_[condicao]):", array_[condicao])

# Exemplo direto, como nas anotações:
print("\nCondição para valores pares (array_ % 2 == 0):", array_ % 2 == 0)
print("Filtrando apenas os valores pares:", array_[array_ % 2 == 0])
